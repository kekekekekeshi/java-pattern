package ink.cecece.pattern;

/**
 * 软件设计原则：
 *      - 迪米特法则（最少知识原则）：一个软件实体尽可能少的与其他实体相互作用
 *      - 单一职责原则（单一功能原则）：单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分
 *      - 开闭原则：软件实体对扩展开放，对修改封闭。
 *      - 里氏替换原则：继承必须确保超类所拥有的性质在子类中仍然成立(子类可以扩展父类的功能，但不能改变父类原有的功能)
 *      - 依赖倒置原则：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象，其核心思想是：要面向接口编程，不要面向实现编程。
 *      - 接口隔离原则：客户端不应该被迫依赖于它不使用的方法，另外一个定义：一个类对另一个类的依赖应该建立在最小的接口上
 *      - 合成复用原则（组合/聚合复用原则）：它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。
 *
 *  23种常见设计模式
 *      - 分为三类：创建型、结构型、行为型
 *      - 创建型
 *          - 分为五种：单例、工厂方法、抽象工厂、建造者、原型
 *      - 结构型
 *          - 分为七种：代理、外观、组合、装饰、享元、适配器、桥接
 *      - 结构型
 *          - 分为十一种：
 * 创建型
 *      - 单例模式：指一个类只有一个实例，且该类能自行创建这个实例的一种模式
 *          - 特点
 *              - 只有一个实例对象
 *              - 实例对象由本身创建，构造器私有化
 *              - 对外提供一个全局访问点
 *          - 分类
 *              - 懒汉式：延时加载，非线程安全
 *              - 饿汉式：不能延时加载，非线程安全
 *              - 双重锁：延时加载，线程安全
 *              - 静态内部类：延时加载，线程安全（类加载基于线程安全实现）
 *              - 枚举：枚举基于单例实现
 *      - 工厂方法模式：如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”，它不属于 GoF 的 23 种经典设计模式，它的缺点是增加新产品时会违背“开闭原则”。
 *              - 工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。
 *              - 优点
 *                  - 用户只需要知道具体工厂名称，就可以得到所要的产品，无需知道产品的生产过程。
 *                  - 在系统中新增产品只需要新增具体产品类和对应的工厂，无需对原有工厂进行修改，满足开闭原则
 *              - 缺点
 *                  - 每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。
 *      - 抽象工厂模式：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。
 *              - 抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。
 *              -抽象工厂一般需要满足的条件
 *                  - 系统中有多个品族，每个具体工厂创建同一族，但属于不同等级结构的产品
 *                  - 系统一次只可能消费某一族产品，即同族产品一起使用
 *              - 优点
 *                  - 可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类进行管理
 *                  - 当增加一个新品族时不需要修改原代码，满足开闭原则
 *              - 缺点
 *                  - 当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。
 *      - 建造者模式：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。
 *              - 优点
 *                  - 各个建造者相互独立，有利于系统的扩展
 *                  - 客户端不需要知道产品内部组成的细节，便于控制细节风险
 *              -缺点
 *                  - 产品组成部分必须相同，限制了使用范围
 *                  - 如果产品内部变化复杂，该模式会增加很多建造者类
 *      - 原型模式：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象
 *              - 实现：实现Cloneable接口，重写clone方法
 *
 * 结构型
 *      - 代理模式：为真实对象提供一个代理，从而控制对真实对象的访问
 *              - 分为静态代理和动态代理
 *              - 动态代理分为JDK提供的动态代理和CGLIB提供的动态代理
 *              - JDK动态代理需要实现InvocationHandler接口,重写invoke方法，通过Proxy.newProxyInstance()方法获得代理对象
 *              - CGLIB动态代理需要实现MethodIntercept接口，重写intercept方法，通过CGLIB增强类对象Enhancer获取代理对象
 *              - 优点
 *                  - 保护目标对象
 *                  - 降低目标对象与客户端的耦合
 *                  - 扩展目标对象的功能
 *              - 缺点
 *                  - 增加一个代理对象，造成请求处理速度变慢
 *                  - 增加了系统的复杂度
 *      - 适配器模式：使原本由于接口不兼容而不能一起工作的类可以在一起工作
 *              - 可以单向适配，也可以双向适配
 *              - 优点
 *                  - 客户端通过适配器可以透明的调用目标接口
 *                  - 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类
 *                  - 将目标与适配者类解藕，解决了目标与适配者类接口不一致的问题
 *              - 缺点
 *                  - 对适配器来说，更换适配器的实现过程比较复杂
 *      - 桥接模式：处理多层继承结构，处理多维度变化场景，将各个维度设计成独立的继承结构，使各个维度可以独立扩展在抽象层建立联系。
 *              - 优点
 *                  - 由于抽象与现实分离，所以扩展能力强
 *                  - 其实现细节对客户透明
 *              - 缺点
 *                  - 由于聚合关系建立在抽象层，要求开发者针对抽象化进行编程和设计，增加了系统理解与设计难度
 *      - 组合模式：将对象组合成树状结构以表示“部分和整体”层次结构，使得客户可以统一调用叶子对象和容器对象。
 *              - 优点
 *                  - 客户端可以一致处理单个对象或者组合对象，无需关心处理的是单个还是组合对象，简化客户端代码。
 *                  - 更容易在组合体内增加新对象，客户端不会因为新加入了对象而更改源码，满足开闭原则。
 *              - 缺点
 *                  - 设计较复杂，客户端需要花更多时间清理类层次关系
 *                  - 不容易限制容器中的组件
 *                  - 不容易用继承的方式来增加组件的新功能
 *      - 装饰模式：给对象动态的添加额外的功能，比继承方式灵活。
 *              - 优点
 *                  - 装饰模式扩展对象的功能比继承扩展更灵活
 *                  - 可以设计出不同的具体装饰类，创造出多个不同行为的组合
 *              - 缺点
 *                  - 装饰类增加了许多子类，如果过度使用会使系统变得很复杂
 *      - 外观模式：为子系统提供统一的调用接口，使得子系统更加容易使用。
 *              - 优点
 *                  - 降低子系统与客户端间的耦合，使得子系统变化不影响调用它的客户类
 *                  - 对客户屏蔽了子组件，减少客户类处理对象数目，使得子系统用起来更容易
 *                  - 降低大型软件编译依赖性，简化系统在不同平台的移植过程，因为编译一个子系统不会影响其他系统，也不会影响外观对象
 *              - 缺点
 *                  - 不能很好的限制客户使用子系统类
 *                  - 增加新的子系统可能需要修改外观类或者客户类，违背开闭原则
 *      - 享元模式：运用共享技术有效的实现管理大量细粒度对象，节省内存，提高性能。
 *              - 优点
 *                  - 相同对象只需保存一份，降低系统中对象的数量，从而降低细粒度对象对 内存造成的压力。
 *              - 缺点
 *                  - 为了使对象可以共享，需要将不能共享的状态外部化，增加了程序的复杂性
 *                  - 读取享元模式外部状态会使得运行时间变长。
 * 行为型
 *      - 责任链模式：避免请求发送者与多个请求耦合在一起，将所有请求的处理者通过前一个对象记住下一个对象的引用而形成一条链，当有请求发生时，可将请求沿着这条链传下去，知道处理它为止。
 *              - 优点
 *                  - 降低了对象之间的耦合度，该模式使得一个对象无需知道是哪一个对象处理请求和链的结构，发送者和接收者无需拥有对方明确的信息。
 *                  - 增强了系统的可扩展性，满足开闭原则。
 *                  - 增强了给对象指派职责的灵活性，当工作流程发生变化，可以动态改变链的顺序或者新增删除链成员。
 *                  - 责任链简化了 对象之间的连接，每个对象只需保持一个指向其后继者的引用，不需要保持其他处理者的引用，避免些写很多if-else
 *                  - 责任分担，每个类只需要处理自己职责范围内的工作，之外的继续往下传递。符合单一职责原则。
 *              - 缺点
 *                  - 不能保证每一个请求一定被处理。
 *                  - 对较长的职责链，系统性能将受到影响
 *                  - 职责链建立的合理性要靠客户端来保证，增加客户类的复杂性。可能造成循环链。
 *      - 迭代器模式：提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示
 *              - 优点
 *                  - 访问一个聚合对象内容而无需暴露它的内部表示。
 *                  - 遍历任务交由迭代器来完成，简化聚合类
 *                  - 它支持不同方式遍历一个聚合，甚至可以定义迭代器子类以支持新的遍历。
 *                  - 增加新的聚合类和迭代器都很方便，无需修改原有代码。
 *                  - 封装性良好，为遍历不同的聚合结构提供统一接口。
 *              - 缺点
 *                  - 增加了类的个数，这在一定程度上增加了系统的复杂性。
 *      - 模板方法模式：定义一个操作中的算法骨架，而将算法延迟到子类实现。使得子类不可以改变算法结构的情况下，重新定义算法的某些步骤。
 *              - 优点
 *                  - 它封装了不变部分，扩展可变部分，它把不变部分封装在父类，把可变部分放在子类实现。
 *                  - 它在父类中提取了公共部分的代码，便于代码复用。
 *                  - 部分方法是由子类实现的，因此子类可以通过扩展的方式增加相应的功能。
 *              - 缺点
 *                  - 对每个不同的实现都需要定义一个子类，这会导致类的数量增加，系统更加庞大，设计也更加抽象。
 *                  - 父类中的抽象方法由子类实现，子类执行结果会影响父类结果，这导致一种反向的控制结构，提高了代码阅读难度。
 *      - 策略模式：该模式定义了一系列算法，并将每个算法封起来，使它们可以相互替换，且算法变化不影响使用它的客户类。
 *              - 优点
 *                  - 多重条件语句不利于维护，策略模式可以避免这种情况
 *                  - 策略模式提供了一系列的可供重用的算法族，恰当使用继承可以将算法族公共部分转移到父类里边，从而避免写重复代码。
 *                  - 策略模式可以提供相同行为的不同实现，客户可以根据不同时空选择不同的策略。
 *                  - 策略模式对开闭原则完美支持，可以在不修改原代码基础上，灵活增加新算法。
 *                  - 策略模式把算法的使用放在环境类中，而算法的实现则放在策略类中，实现二者分离。
 *              - 缺点
 *                  - 客户端必须理解所有策略算法的区别
 *                  - 策略模式造成很多的策略类
 *      - 观察者模式：指多个对象间存在一对多的依赖关系，当一个对象发生改变时，所有依赖于它的对象都得到通知并自动更新。
 *              - 优点
 *                  - 降低了目标与观察者间的耦合度，两者间是抽象耦合关系。
 *                  - 目标与观察者间建立了一套触发机制。
 *              - 缺点
 *                  - 目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用
 *                  - 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。
 *      -
 * */
public class Pattern {
}
